"use client";

import { useState, useEffect } from "react";
import { Connection, PublicKey } from "@solana/web3.js";
import { Exploit } from "@/types/exploit";

export function useSolanaExploits(programId?: string) {
  const [exploits, setExploits] = useState<Exploit[]>([]);
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<Error | null>(null);

  useEffect(() => {
    const fetchExploits = async () => {
      try {
        setLoading(true);
        // Validate programId
        if (programId && /^[1-9A-HJ-NP-Za-km-z]+$/.test(programId)) {
          try {
            const connection = new Connection("https://api.devnet.solana.com", "confirmed");
            const programPublicKey = new PublicKey(programId);
            const accounts = await connection.getProgramAccounts(programPublicKey);

            const fetchedExploits: Exploit[] = accounts.map((account) => ({
              id: account.pubkey.toString(),
              date: new Date().toISOString(),
              protocol: "On-Chain Protocol",
              type: "Unknown",
              fundsLost: "0",
              transactionId: account.pubkey.toString(),
              createdAt: new Date().toISOString(),
              updatedAt: new Date().toISOString(),
              metadata: { status: "Confirmed" },
            }));

            setExploits(fetchedExploits);
          } catch (err) {
            console.error("Failed to fetch on-chain exploits:", err);
            // Fallback to mock data if on-chain fetch fails
            setExploits(getMockExploits());
          }
        } else {
          // Use mock data if no valid programId
          setExploits(getMockExploits());
        }
        setLoading(false);
      } catch (err) {
        setError(err instanceof Error ? err : new Error("Failed to fetch Solana exploits"));
        setExploits(getMockExploits());
        setLoading(false);
      }
    };

    fetchExploits();
  }, [programId]);

  // Mock data function
  function getMockExploits(): Exploit[] {
    return [
      {
        id: "1",
        date: "2022-02-02T00:00:00.000Z",
        protocol: "Wormhole",
        type: "Signature Verification",
        fundsLost: "326000000000000", // $326M in lamports
        transactionId: "tx_wormhole",
        createdAt: "2022-02-02T00:00:00.000Z",
        updatedAt: "2022-02-02T00:00:00.000Z",
        metadata: { status: "Confirmed" },
      },
      {
        id: "2",
        date: "2022-10-11T00:00:00.000Z",
        protocol: "Mango Markets",
        type: "Oracle Manipulation",
        fundsLost: "116000000000000", // $116M in lamports
        transactionId: "tx_mango",
        createdAt: "2022-10-11T00:00:00.000Z",
        updatedAt: "2022-10-11T00:00:00.000Z",
        metadata: { status: "Confirmed" },
      },
      {
        id: "3",
        date: "2025-04-17T00:00:00.000Z",
        protocol: "SolFlare Protocol",
        type: "Reentrancy",
        fundsLost: "8200000000000", // $8.2M in lamports
        transactionId: "tx_solflare",
        createdAt: "2025-04-17T00:00:00.000Z",
        updatedAt: "2025-04-17T00:00:00.000Z",
        metadata: { status: "Confirmed" },
      },
    ];
  }

  return { exploits, loading, error };
}